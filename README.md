# Kria FPGA/SoC HLS Demonstrations

This repository provides a comprehensive set of High-Level Synthesis (HLS) IP cores and bare-metal application examples tailored for the **AMD/Xilinx Kria™ KR260 Robotics Starter Kit** or equivalent Zynq® UltraScale+™ MPSoC platforms. The examples showcase the end-to-end design flow: **HLS kernel design** → **Vivado IP integration** → **Vitis platform generation** → **bare-metal software execution**.

---

## Repository Contents

| Directory / File               | Description                                                                                  |
|--------------------------------|----------------------------------------------------------------------------------------------|
| `HLS_LFSR/`                    | 8-bit Linear Feedback Shift Register (LFSR) HLS IP, testbenches, and bare-metal driver example. |
| `adder_HLS/`                   | 32-bit integer adder HLS IP, testbenches, and bare-metal driver example.                     |
| `helloworld.cpp`               | Minimal bare-metal application for platform and UART sanity check.                           |
| `design_LFSR_IP_wrapper.xsa`   | Pre-generated Vivado hardware design (XSA) with LFSR IP for direct Vitis use.                |
| `xparameters.h`                | Hardware parameters and base addresses generated by Vitis for bare-metal software.           |

---

## Target Platform

- **Board:** Kria KR260 Robotics Starter Kit (or other Kria SOM with matching PS/PL configuration)
- **Device:** Zynq UltraScale+ MPSoC (`xczu5ev-sfvc784-1-e`)
- **Toolchain Versions Tested:**
  - Vivado 2023.2 (or later)
  - Vitis 2023.2 (or later)
  - Vitis HLS 2023.2 (or later)
- **Operating System:** Bare-metal (no OS), running on ARM Cortex-A53 cores

---

## Project Overview

### 1. **HLS_LFSR**
Implements an **8-bit maximal-length Linear Feedback Shift Register (LFSR)** with the polynomial:

```
x^8 + x^6 + x^5 + x^4 + 1
```

**Features:**
- Seed storage in on-chip BRAM
- Software-controlled seed initialization
- Prevents all-zero LFSR state
- AXI-Lite register interface for software control

**Includes:**
- `LFSR_IP.cpp`: Synthesizable HLS design
- `lfsr_ip_tb.cpp`: C-level testbench for functional verification
- `lfsr_ip_tb_bareMetal.cpp`: Bare-metal driver example accessing IP registers via AXI-Lite

**Register Map:**
| Offset | Name         | Access | Description                              |
|--------|--------------|--------|------------------------------------------|
| 0x00   | CTRL         | R/W    | Control register (bit 0: start, bit 1: reset) |
| 0x04   | SEED         | R/W    | 8-bit seed value for LFSR initialization |
| 0x08   | OUTPUT       | R      | Current 8-bit LFSR output value          |

---

### 2. **adder_HLS**
Implements a **32-bit unsigned integer adder** with an AXI-Lite interface.

**Features:**
- Inputs `a` and `b` via AXI-Lite registers
- Output `sum` accessible via AXI-Lite
- Simple bare-metal driver for hardware testing

**Includes:**
- `adder_HLS.cpp`: Synthesizable HLS design
- `adder_HLS_tb.cpp`: C-level testbench
- `adder_HLS_bareMetal.cpp`: Bare-metal driver example

**Register Map:**
| Offset | Name         | Access | Description                              |
|--------|--------------|--------|------------------------------------------|
| 0x00   | CTRL         | R/W    | Control register (bit 0: start)          |
| 0x04   | INPUT_A      | R/W    | 32-bit input `a`                         |
| 0x08   | INPUT_B      | R/W    | 32-bit input `b`                         |
| 0x0C   | SUM          | R      | 32-bit sum output (`a + b`)              |

---

### 3. **Hello World**
A minimal bare-metal application to verify:
- Platform initialization (`init_platform()`)
- UART functionality
- Basic Vitis application build process

**Includes:**
- `helloworld.cpp`: Basic UART output example

---

## Prerequisites

- **Hardware:** Kria KR260 Robotics Starter Kit or compatible Zynq UltraScale+ MPSoC board
- **Software:**
  - AMD Vivado 2023.2 (or later)
  - AMD Vitis 2023.2 (or later)
  - AMD Vitis HLS 2023.2 (or later)
- **Dependencies:** Serial terminal software (e.g., `screen`, `minicom`, or Tera Term)
- **Cables:** USB-UART cable for serial communication

---

## Build Instructions

### Step 1: Simulate and Verify in Vitis HLS
1. Open Vitis HLS:
   ```bash
   vitis_hls
   ```
2. Create a new project, add HLS source (e.g., `LFSR_IP.cpp` or `adder_HLS.cpp`).
3. Set the target part to `xczu5ev-sfvc784-1-e`.
4. Run C Simulation using the provided testbench (e.g., `lfsr_ip_tb.cpp`).

---

### Step 2: Export HLS IP
1. In Vitis HLS, navigate to **Solution → Export RTL → VHDL/Verilog**.
2. Package the IP as a `.zip` file for Vivado integration.

---

### Step 3: Create Vivado Block Design
1. Open **Vivado** and create a new project for `xczu5ev-sfvc784-1-e`.
2. Add the exported HLS IP to the IP Catalog.
3. Create a Block Design:
   - Add **Zynq UltraScale+ MPSoC Processing System**.
   - Add the HLS IP (LFSR or Adder).
   - Connect AXI-Lite interfaces and clocks.
4. Generate the bitstream.
5. Export Hardware (**File → Export → Export Hardware**) with the bitstream to produce an `.xsa` file.

*Note:* The repository includes `design_LFSR_IP_wrapper.xsa` to skip this step for the LFSR IP.

---

### Step 4: Create Vitis Platform
1. In **Vitis**, create a new Platform Project:
   ```bash
   File → New → Platform Project
   ```
2. Select the exported `.xsa` file (or use the provided `design_LFSR_IP_wrapper.xsa`).
3. Build the platform.

---

### Step 5: Build Bare-Metal Application
1. Create an **Application Project** in Vitis:
   - Select the created platform.
   - Choose the `standalone` domain.
2. Add one of the provided bare-metal examples:
   - `lfsr_ip_tb_bareMetal.cpp`
   - `adder_HLS_bareMetal.cpp`
   - `helloworld.cpp`
3. Build the project.
4. Program the device and run the application using the Vitis debugger or `xsct`.

---

## Running on Hardware
1. Connect the USB-UART cable to the host PC.
2. Open a serial terminal:
   ```bash
   screen /dev/ttyUSB0 115200
   ```
3. Reset and run the application via Vitis or `xsct`.

---

## Example Usage
### LFSR Example
1. Load the `lfsr_ip_tb_bareMetal.cpp` application.
2. Write a non-zero seed to the `SEED` register (offset 0x04).
3. Set the `start` bit in the `CTRL` register (offset 0x00).
4. Read the LFSR output from the `OUTPUT` register (offset 0x08).

### Adder Example
1. Load the `adder_HLS_bareMetal.cpp` application.
2. Write values to `INPUT_A` (offset 0x04) and `INPUT_B` (offset 0x08).
3. Set the `start` bit in the `CTRL` register (offset 0x00).
4. Read the result from the `SUM` register (offset 0x0C).

---

## License
MIT License — See the [LICENSE](LICENSE) file for details.

---

## Author
Mahanta Talakal, K K Lakshmi, Madhusudana AV, Jugal Modi

---

## References
- [AMD Kria SOM Documentation](https://www.amd.com/en/products/som/kria.html)
- [Vitis Unified Software Platform Documentation](https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration)
- [Vivado Design Suite Documentation](https://docs.xilinx.com/v/u/en-US/ug973-vivado-release-notes-install-license)

---

## Contributing
Contributions are welcome! Please submit a pull request or open an issue for suggestions or bug reports.
